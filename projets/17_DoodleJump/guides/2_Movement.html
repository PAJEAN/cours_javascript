<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouvement</title>
</head>
<body>
    <canvas id="my_canvas" width="110" height="110" style="border: 1px solid red"></canvas>

    <script>
        let _startTime     = Date.now();
        let _lag           = 0;
        let _fps           = 60; // Frame rate.
        let _frameDuration = 1000 / _fps; // Avec 60 frame par seconde, la frame va durer 16.7ms.
        let _position      = {x: 0, y:0};
        let _timer         = 0;

        let _gravitySpeed = 0;
        let _gravity = 20;

        /*
            Nous appelons la méthode de déplacement selon un taux de rafraichissement donné (disons 60fps).
            Nous modulons notre vitesse pour qu'elle corresponde au nombre de cellules de notre grille parcourues par seconde (dépendant des fps indiquées).
            Si nous voulons qu'une cellule soit parcourue en 1 seconde alors le cube doit se déplacer de (1 / 60)% de la case par frame (si 60fps).
            Lorsque le taux de rafraîchissement est diminué à 30fps alors la boucle while empêche l'exécution d'une frame sur 2 environ car le deltaTime est toujours identique à 16ms (dépendant de la fonction requestAnimationFrame).
            A l'inverse si le taux est plus élevé, par exemple à 90fps, alors la durée d'une frame sera de 11ms. Le deltaTime sera toujours de 16ms et nous accumulerons un retard de 5ms par appel. Ainsi, toutes les 3 frames environ, il y aura une régularisation à l'aide de la boucle while.
        */

        /**
         * Déplacement de notre cube au sein du canvas.
         */
        let Move = function() {
            _gravitySpeed += _gravity;
            _position.y += _gravitySpeed / _fps;
        }

        /**
         * Afficher le canvas et le mouvement du carré.
         */
        let Display = function() {
            let x = _position.x;
            let y = _position.y;
            let canvas = document.getElementById('my_canvas');
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dessiner les lignes.
            ctx.beginPath(); // Nouveau tracé.
            ctx.moveTo(100, 0); // Déplacement du crayon en (100, 0).
            ctx.lineTo(100, 100); // Dessiner la ligne en (150, 100).
            ctx.stroke(); // Afficher la ligne.
            ctx.beginPath(); // Nouveau tracé.
            ctx.moveTo(0, 100); // Déplacement du crayon en (100, 0).
            ctx.lineTo(100, 100); // Dessiner la ligne en (150, 100).
            ctx.stroke(); // Afficher la ligne.
            
            // Dessiner un rectangle plein.
            ctx.fillRect(x, y, 10, 10);
        }

        /**
         * Actualisation du canvas selon un fps donné.
         */
        let Update = function() {
            /* Calcul du deltaTime */
            let currentTime = Date.now();
            let deltaTime   = currentTime - _startTime; // La durée entre deux appels (entre 2 frames).
            _lag += deltaTime;
            _startTime = currentTime;
            _timer += deltaTime;

            /* Mettre à jour la logique si la variable _lag est supérieure ou égale à la durée d'une frame */
            while (_lag >= _frameDuration) {
                /* Mise à jour de la logique et de la vue */
                Move();
                Display();
                /* Réduire la variable _lag par la durée d'une frame */
                _lag -= _frameDuration;
            }

            if (_position.y < 100) {
                requestAnimationFrame(Update); // La fonction de rappel est généralement appelée 60 fois par seconde.
            }
            
            console.log(_position, _timer / 1000);
        }

        Update();

        /*
            Exercice3:
            ----------
            Lorsque le cube atteint 100 pixel en y, faites le rebondir.

            Exercice4:
            ----------
            Déplacer le carré de gauche à droite à l'aide des évènements liés au clavier.

            ```
            document.addEventListener('keydown', (evt) => {
                if (evt.key == 'ArrowLeft' || evt.key == 'ArrowRight') {

                    switch (evt.key) {
                        case 'ArrowLeft': // Move left.
                            this._hold_left = true;
                            // Change direction.
                            break;
                        case 'ArrowRight': // Move right.
                            this._hold_right = true;
                            // Change direction.
                            break;
                    }
                }
            });
            document.addEventListener('keyup', (evt) => {
                switch (evt.key) {
                    case 'ArrowLeft': // Move left.
                        if (!this._hold_right) {
                            // Change direction.
                        }
                        this._hold_left = false;
                        break;
                    case 'ArrowRight': // Move right.
                        if (!this._hold_left) {
                            // Change direction.
                        }
                        this._hold_right = false;
                        break;
                }
            });
            ```

            Exercice5:
            ----------
            Effectuer ce même exercice à travers l'architecture MVC (https://github.com/PAJEAN/cours_javascript/tree/master/TP/MVC) en utilisant des fonctions callback entre les classes.
        */
    </script>
    
</body>
</html>