<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Le JavaScript</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="wrapper">
        <div class="page" id="page">
            <div id="header-container">Les objets</div>

            <p>
                Un objet est un <b>ensemble de propri√©t√©s</b>, o√π chaque propri√©t√© associe un <b>nom (ou cl√©) √† une valeur</b>. Si cette valeur est une fonction, la propri√©t√© est alors appel√©e m√©thode. Le nom d'une propri√©t√© peut √™tre une cha√Æne de caract√®res ou un nombre.
            </p>

            <h2> Cr√©ation d'un objet </h2>

            <p>
                Il y a plusieurs fa√ßon de cr√©er un objet (notamment depuis ES6).
            </p>

            <div id="cells74"></div>

            <p>
                Une fa√ßon alternative est de cr√©er une instance de <code>Object</code> au travers de son constructeur est d'exploiter le mot-cl√© <code>new</code>.
            </p>

            <div id="cells75"></div>

            <p>
                Les deux pr√©c√©dentes m√©thodes ne sont pas les plus courantes lorsque nous devons g√©n√©raliser l'objet que nous manipulons (c'est-√†-dire utiliser l'objet comme un <i>template</i> - classe - pour cr√©er de nouveaux objets). Dans ce cas, il faut d√©finir un <b>constructeur</b> personnalis√©.
            </p>

            <p>
                Les constructeurs, comme la plupart des autres langages orient√©s objets, <b>fournissent un <i>template</i> pour cr√©er des objets</b>. En d'autres termes, ils d√©finissent un ensemble de propri√©t√©s et m√©thodes qui pourrait √™tre commun √† tous les objets initialis√©s par le constructeur.
            </p>

            <div id="cells76"></div>

            <p>
                Depuis la sp√©cification ECMAScript 6 (pour information ES6 a √©t√© valid√© et publi√© le 17 juin 2015) une syntaxe alternative a √©t√© introduite pour cr√©er des objets et g√©rer l'h√©ritage.
            </p>

            <div id="cells77"></div>

            <h2> H√©ritage et la cha√Æne de prototypage </h2>

            <p>
                JavaScript est un langage orient√© prototype, une forme particuli√®re de programmation orient√©e objet. Dans ce mod√®le, les objets peuvent h√©riter directement d'autres objets gr√¢ce au <b>m√©canisme des prototypes</b>.
            </p>

            <h3> Propri√©t√©s h√©rit√©es </h3>

            <p>
                En JavaScript, chaque objet poss√®de en interne une propri√©t√© cach√©e appel√©e <b><code>[[Prototype]]</code></b> (qu'on ne voit pas directement dans le code).
            </p>

            <ul>
                <li> Elle sert √† cr√©er une cha√Æne de prototypes pour l'h√©ritage. </li>
                <li> Lorsqu'on utilise une propri√©t√© sur un objet, JavaScript la cherche dans l'objet ‚Üí puis dans son <code>[[Prototype]]</code> ‚Üí puis dans le <code>[[Prototype]]</code> de celui-ci, etc., jusqu'√† arriver √† <code>null</code>. </li>
            </ul>

            <p>
                Pour y acc√©der, il existe la propri√©t√© <code>__proto__</code> qui est simplement un raccourci pour lire ou modifier <code>[[Prototype]]</code>.
            </p>

            <div id="cells78-1"></div>

            <p>
                Ici <code>obj.__proto__</code> permet de voir le prototype r√©el de <code>obj</code>, qui est <code>Object.prototype</code>. Mais <code>__proto__</code> n'est pas une "vraie" propri√©t√© de l'objet lui-m√™me : c'est un accesseur d√©fini sur <code>Object.prototype</code> qui permet d'acc√©der √† la propri√©t√© interne <code>[[Prototype]]</code> d'un objet.
            </p>

            <p>
                En JavaScript, chaque fonction poss√®de une propri√©t√© sp√©ciale appel√©e prototype, utilis√©e comme base pour cr√©er des objets h√©ritiers avec <code>new</code>.
            </p>

            <div id="cells78"></div>            

            <p>
                Les propri√©t√©s directement rattach√©es √† un objet sont appel√©es propri√©t√©s propres (<i>own properties</i>). Lorsqu'on tente d'acc√©der aux propri√©t√©s d'une instance d'un objet, la propri√©t√© sera recherch√©e tout d'abord sur ses propri√©t√©s propres puis sur son prototype, puis sur le prototype du prototype et ainsi de suite jusqu'√† ce qu'elle soit trouv√©e ou que la fin de la cha√Æne de prototype ait √©t√© atteinte.
            </p>

            <div id="cells80"></div>

            <h3> M√©thodes h√©rit√©es </h3>

            <p>
                En JavaScript, toute fonction associ√©e √† un objet est √©galement une propri√©t√©. Par cons√©quent, une fonction h√©rit√©e se comportera comme n'importe quelle autre propri√©t√©.
            </p>

            <p>
                Par exemple, le <code>__proto__</code> d'un tableau pointe vers le prototype de l'objet <code>Array</code>. C'est pourquoi, un tableau h√©rite de toutes les propri√©t√©s et m√©thodes de l'objet <code>Array</code> (<code>length</code>, <code>map</code>, etc.).
            </p>

            <p>
                La programmation orient√©e prototype offre, par cons√©quent, la possibilit√© d'ajouter des m√©thodes √† tout moment en dehors de la fonction constructeur. Il est possible par exemple d'ajouter une m√©thode au prototype de l'objet <code>Array</code> (cette pratique, d'ajouter des fonctions aux objets natifs, <b>est cependant d√©conseill√©e</b>).
            </p>

            <div id="cells82"></div>

            <p>
                Voici un exemple complet d'h√©ritage avant la version ES6. Il est possible d'utiliser la fonction <code>call()</code> de l'objet <code>Function</code> pour cha√Æner le constructeur d'un objet.
            </p>

            <div id="cells83"></div>

            <p>
                Voici un exemple complet d'h√©ritage apr√®s la version ES6. Le sucre syntaxique ajout√© lors de la version ES6 exploite le mot-cl√© <code>extends</code> pour h√©riter des attributs et des m√©thodes d'une classe.
            </p>

            <div id="cells84"></div>
            
            <div class="nota-bene-box">
                <div class="nota-bene-header">
                    <span class="box-icon">üìù</span>
                    <span class="box-title">√Ä savoir</span>
                </div>
                <div class="box-content">
                    <p> JavaScript ne supporte pas l'h√©ritage multiple. </p>
                </div>
            </div>
            
            <h3> M√©thodes statiques </h3>

            <p>
                Le mot-cl√© <code>static</code> permet de d√©finir une m√©thode statique d'une classe. Les m√©thodes statiques ne sont pas disponibles sur les instances d'une classe mais sont appel√©es sur la classe elle-m√™me. Les m√©thodes statiques sont g√©n√©ralement des fonctions utilitaires (qui peuvent permettre de cr√©er ou de cloner des objets par exemple).
            </p>

            <div id="cells85"></div>

            <h3> La copie d'un objet </h3>

            <p>
                Les <b>objets en JavaScript sont muables</b>. La copie d'un objet <b>s'effectue par r√©f√©rence</b> et non par valeur.
            </p>

            <div id="cells86"></div>

            <div id="cells87"></div>

            <p>
                La m√©thode <code>Object.assign()</code> peut √™tre utilis√©e afin de copier les valeurs de toutes les propri√©t√©s propres d'un objet qui sont √©num√©rables sur une autre objet.
            </p>

            <div id="cells88"></div>

            <h3> Le mot-cl√© <code>this</code> </h3>

            <p>
                Lorsque l'on manipule des objets, le mot-cl√© <code>this</code> est utilis√© avec les m√©thodes de l'objet pour acc√©der √† des informations stock√©es dans l'objet. Le mot-cl√© <code>this</code> va dans ce cas √™tre substitu√© par l'objet utilisant la m√©thode lors de son appel.
            </p>

            <p>
                Pour aller plus loin, vous devez savoir qu'en JavaScript, √† la diff√©rence de la plupart des langages, le mot-cl√© <code>this</code> <b>n'est pas li√© √† un objet en particulier</b>. En effet, la valeur de <code>this</code> va √™tre √©valu√©e au moment de l'appel de la m√©thode dans laquelle il est pr√©sent en JavaScript.
            </p>

            <p>
                Ainsi, la valeur de <code>this</code> ne va pas d√©pendre de l'endroit o√π la m√©thode a √©t√© d√©clar√©e mais de l'objet qui l'appelle. Cela permet notamment √† une m√©thode d'√™tre r√©utilis√©e par diff√©rents objets.
            </p>

            <div id="cells89"></div>

            <p>
                <code>this</code> est un op√©rateur qui permet de retourner une valeur en fonction de son contexte <i>confer</i> <a href="../../exemples/this/this.html">l'exemple suivant</a>.
            </p>

            <div class="exercise-box">
                <div class="exercise-header">
                    <span class="box-icon">üí°</span>
                    <span class="box-title">Exercice</span>
                </div>
                <div class="box-content">
                    <p> Rendez-vous au lien suivant: <b>https://github.com/PAJEAN/cours_javascript/tree/master/exemples/bfs</b> pour r√©aliser le TP sur le parcours en largeur de graphe. </p>
                </div>
            </div>

            <button class="btn toggle-answer" data-pw="re">
                Afficher la r√©ponse
            </button>
            <div class="hidden">

<textarea class="editor mt" spellcheck="false">
class Graph {
    constructor(matrix) {
        this.matrix = matrix;
    }
    /* Node name from their index */
    _nodeName(index) { return `n${index}`; }
    /* Convert the adjacency matrix to dot language in order to use viz.js */
    _toDotLanguage() {
        let _createId = (num1, num2) => `${num1}${num2}`;

        let graph = [];
        let seen_indexes = {};
        for (let i = 0; i < this.matrix.length; i++) {
            for (let j = 0; j < this.matrix.length; j++) { // this.matrix is a square matrix (same number of rows and columns).
                let id = _createId(i, j);

                if (id in seen_indexes || this.matrix[i][j] == 0) continue;

                let is_dir_both = false;
                if (this.matrix[j][i] == 1) {
                    is_dir_both = true;
                    seen_indexes[_createId(j, i)] = true;
                }
                graph.push(`${this._nodeName(i)} -> ${this._nodeName(j)}${is_dir_both ? ' [dir="both"]': ''}`);
            }
        }
        return `digraph { ${graph.join(' ')} }`;
    }
    /* Compute all distances between all nodes and a given node */
    distance(i_root) {
        let distances = {[this._nodeName(i_root)]: 0};
        let current_distance = 1;
        let queue = [i_root];
        while (queue.length > 0) {
            let current_node_index = queue.shift();
            let current_node = this.matrix[current_node_index];
            for (let j = 0; j < current_node.length; j++) {
                if (this._nodeName(j) in distances || current_node[j] == 0) continue;
                distances[this._nodeName(j)] = current_distance;
                queue.push(j);
            }
            current_distance += 1;
        }
        console.log(distances);
        return distances;
    }
    /* Display graph */
    display() {                    
        let viz = new Viz();
        viz.renderSVGElement(this._toDotLanguage())
        .then(function(element) {
            document.body.appendChild(element);
        })
        .catch(error => {
            // Possibly display the error
            console.error(error);
        });
    }
}

var matrix = [
    [0, 1, 1, 1, 0],
    [0, 0, 1, 0, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 0, 0, 0]
];

let graph = new Graph(matrix);
graph.display();
for (let i = 0; i < this.matrix.length; i++) {
    graph.distance(i);
}
</textarea>

            </div>

        </div>
    </div>


<!--
88888888888                              888          888            
    888                                  888          888            
    888                                  888          888            
    888   .d88b.  88888b.d88b.  88888b.  888  8888b.  888888 .d88b.  
    888  d8P  Y8b 888 "888 "88b 888 "88b 888     "88b 888   d8P  Y8b 
    888  88888888 888  888  888 888  888 888 .d888888 888   88888888 
    888  Y8b.     888  888  888 888 d88P 888 888  888 Y88b. Y8b.     
    888   "Y8888  888  888  888 88888P"  888 "Y888888  "Y888 "Y8888  
                                888                                  
                                888                                  
                                888                                  
-->

    <div id="template-container"></div>


<!--
 .d8888b.                   d8b          888    
d88P  Y88b                  Y8P          888    
Y88b.                                    888    
 "Y888b.    .d8888b 888d888 888 88888b.  888888 
    "Y88b. d88P"    888P"   888 888 "88b 888    
      "888 888      888     888 888  888 888    
Y88b  d88P Y88b.    888     888 888 d88P Y88b.  
 "Y8888P"   "Y8888P 888     888 88888P"   "Y888 
                                888             
                                888             
                                888             
-->

    <script src="../js/main.js"></script>

    <script>
        /* ==== Add cells ==== */
   
addCell('cells74', 'Syntaxe litt√©rale', `
let ma_cle = 'nom_magicien';
let heros = {
    nom: 'Geralt', //Propri√©t√© de l'objet.
    profession: 'Sorceleur', // Propri√©t√© de l'objet.
    10: 'Une partie de Gwent ?', // Propri√©t√© de l'objet.
    'monstres tu√©s': 134, // Propri√©t√© de l'objet.
    direBonjour: function() { // M√©thode de l'objet.
        console.log('Humm !');
    },
    [ma_cle]: 'Yennefer' // Instanciation d'une cl√© 
}
console.log(heros.nom);
console.log(heros[10]);
console.log(heros['monstres tu√©s']);
heros.direBonjour();
console.log(heros[ma_cle]);
console.log(heros.nom_magicien);
`);

addCell('cells75', 'Constructeur <code>Object</code>', `
let heros = new Object(); // On cr√©√© une instance de Object gr√¢ce √† son constructeur.
heros.nom = 'Geralt'; // Propri√©t√©.
heros.direBonjour = function() { // M√©thode de l'objet.
    console.log('Humm !');
};
heros.direBonjour();
`);

addCell('cells76', 'Constructeur personnalis√©', `
function afficher() {
    console.log(this.nom + ' ' + this.age);
}

function Animal(nom, age) { // Constructeur.
    this.nom = nom;
    this.age = age;
    // D√©finition de la m√©thode toString √† partir de la fonction afficher.
    this.toString = afficher;
}

let animal1 = new Animal('Flipper', 8);
let animal2 = new Animal('Beethoven', 4);
console.log(animal1.nom);
console.log(animal2.nom);

// Utilisation de la m√©thode valueOf().
console.log(animal1.valueOf());
`);

addCell('cells77', 'Constructeur personnalis√© (syntaxe alternative)', `
class Animal {
    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
    }

    // D√©finition de la m√©thode toString().
    toString() {
        console.log(this.nom + ' ' + this.age);
    }
}

var animal1 = new Animal('Flipper', 8);
console.log(animal1.nom);
console.log(animal1.valueOf());
`);

addCell('cells78', 'Cha√Æne de prototypage (1/2)', `
function Personne(name) {
  this.name = name;
}

// Chaque fonction a une propri√©t√© "prototype".
console.log(Personne.prototype); // Visualiser avec la console du navigateur.

let p1 = new Personne('Alice');

// L'objet cr√©√© avec new h√©rite de Personne.prototype
console.log(p1.__proto__ === Personne.prototype);
console.log('Prototype de Object: ');
console.log(p1.__proto__.__proto__ === Object.prototype);
console.log('Prototype du prototype de Object: ');
console.log(p1.__proto__.__proto__.__proto__ === null);
`);

addCell('cells78-1', 'Propri√©t√© <code>__proto__</code>', `
const obj = { a: 1 };
console.log(obj.__proto__ === Object.prototype);
`);

addCell('cells80', 'Cha√Æne de prototypage (2/2)', `
let un_objet = function(){
    this.a = 1;
    this.b = 2;
}

un_objet.prototype.b = 3;
un_objet.prototype.c = 4;

let o1 = new un_objet();

// Quelles sont les sorties de ces instructions ?
console.log('o1.a ' + o1.a);
console.log('o1.b ' + o1.b);
/* Je n'ai pas la propri√©t√© "c" dans mes propri√©t√©s propres
Je remonte la cha√Æne de prototypage, est ce que le prototype de mon constructeur (un_objet) a cette propri√©t√© ?
Oui la propri√©t√© est pr√©sente, je l'affiche */
console.log('o1.c ' + o1.c);
`);

addCell('cells82', 'Extension du prototype', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
}

Animal.prototype.manger = function() { 
    console.log(this.nom + ' est en train de manger.');
}

var animal1 = new Animal('Flipper', 4);
animal1.manger();
/* La propri√©t√© (m√©thode) manger() n'est pas pr√©sent dans les propri√©t√©s propres, on remonte vers le prototype de Animal */
`);

addCell('cells83', 'H√©ritage', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
}

Animal.prototype.manger = function() { 
    console.log(this.nom + ' est en train de manger.');
}

function Chien(nom, age, race) {
    Animal.call(this, nom, age); // H√©ritage des attributs.
    this.race = race;
}

Chien.prototype = Object.create(Animal.prototype); // H√©ritage des m√©thodes.

var chien1 = new Chien('Snoopy', 10, 'Labrador');
console.log(chien1.nom + ' est un(e) ' + chien1.race);

chien1.manger();

Animal.prototype.getAge = function() {
    return this.nom + ' a ' + this.age + 'ans';
}

console.log(chien1.getAge());
`);

addCell('cells84', 'H√©ritage (syntaxe alternative)', `
class Animal {
    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
    }
    
    manger() {
        console.log(this.nom + ' est en train de manger.');
    }
}

class Chien extends Animal {
    constructor(nom, age, race) {
        super(nom, age);
        this.race = race;
    }
    
    manger() {
        super.manger();
        console.log('Il mange des croquettes.');
    }
    
}

var chien1 = new Chien('Snoopy', 10, 'Labrador');
console.log(chien1.nom);
chien1.manger();
`);

addCell('cells85', 'Attribut et m√©thode statiques', `
class Animal {
    static cost = 100;

    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
        Animal.count++;
    }
    
    manger() {
        console.log(this.nom + ' est en train de manger.');
    }
    
    static Count() {
        return Animal.count;
    }
}

console.log(Animal.cost);

Animal.count = 0; // D√©claration de l'attribut statique.

var animal1 = new Animal('Flipper', 8);
console.log(Animal.Count());
var animal2 = new Animal('Snoopy', 10);
console.log(Animal.Count());

/* == Cette instruction est-elle viable ? == */

animal2.Count();
`);

addCell('cells86', 'Copie par r√©f√©rence', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
}

var animal1 = new Animal('Flipper', 8);
// Adressage par r√©f√©rence.
var animal2 = animal1;

/* == Quel sera le r√©sultat ? == */

console.log(animal1.nom + ' ' + animal2.nom);

animal2.nom = "Beethoven";

console.log(animal1.nom + ' ' + animal2.nom);
`);

addCell('cells87', 'Copie par valeur', `
var str1 = 'Hello';
// Adressage par valeur.
var str2 = str1;

// Quel sera le r√©sultat ?
console.log(str1);
console.log(str2);

str2 = 'World';

console.log(str1);
console.log(str2);
`);

addCell('cells88', 'M√©thode <code>assign()</code>', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
}

var animal1 = new Animal('Flipper', 8);
var animal2 = Object.assign(Animal, animal1);

/* == Quel sera le r√©sultat ? == */
console.log(animal1.nom + ' ' + animal2.nom);

animal2.nom = "Beethoven";

console.log(animal1.nom + ' ' + animal2.nom);
`);

addCell('cells89', '', `
let pierre = { name: 'Pierre' };
let mathilde = {name: 'Mathilde', age: 32 };

function disBonjour(){
  console.log('Bonjour ' + this.name);
}

pierre.bonjour = disBonjour;
mathilde.bonjour = disBonjour;

pierre.bonjour();
mathilde.bonjour();
`);
    
/*        
    addCell('cells00', '', `

    `);
*/

    </script>
</body>
</html>