<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Le JavaScript</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="wrapper">
        <div class="page" id="page">
            <div id="header-container">Les objets</div>

            <p>
                Un objet est un <b>ensemble de propri√©t√©s</b>, o√π chaque propri√©t√© associe un <b>nom (ou cl√©) √† une valeur</b>. Si cette valeur est une fonction, la propri√©t√© est alors appel√©e m√©thode. Le nom d'une propri√©t√© peut √™tre une cha√Æne de caract√®res ou un nombre.
            </p>

            <h2> Cr√©ation d'un objet </h2>

            <p>
                Il y a plusieurs fa√ßon de cr√©er un objet (notamment depuis ES6).
            </p>

            <div id="cells74"></div>

            <p>
                Une fa√ßon alternative est de cr√©er une instance de <code>Object</code> au travers de son constructeur et d'exploiter le mot-cl√© <code>new</code>.
            </p>

            <div id="cells75"></div>

            <p>
                Les deux pr√©c√©dentes m√©thodes ne sont pas les plus courantes lorsque nous devons g√©n√©raliser l'objet que nous manipulons (c'est-√†-dire utiliser l'objet comme un <i>template</i> - classe - pour cr√©er de nouveaux objets). Dans ce cas, il faut d√©finir un <b>constructeur</b> personnalis√©.
            </p>

            <p>
                Les constructeurs, comme la plupart des autres langages orient√©s objets, <b>fournissent un <i>template</i> pour cr√©er des objets</b>. En d'autres termes, ils d√©finissent un ensemble de propri√©t√©s et m√©thodes qui pourrait √™tre commun √† tous les objets initialis√©s par le constructeur.
            </p>

            <div id="cells76"></div>

            <p>
                Depuis la sp√©cification ECMAScript 6 (pour information ES6 a √©t√© valid√© et publi√© le 17 juin 2015) une syntaxe alternative a √©t√© introduite pour cr√©er des objets et g√©rer l'h√©ritage.
            </p>

            <div id="cells77"></div>

            <h2> H√©ritage et la cha√Æne de prototypage </h2>

            <p>
                L'h√©ritage en programmation orient√©e objet permet √† une classe de <b>r√©cup√©rer les propri√©t√©s et m√©thodes d'une autre classe</b> afin de r√©utiliser et √©tendre le code.
            </p>

            <p>
                JavaScript est <b>un langage orient√© prototype</b>, une forme particuli√®re de programmation orient√©e objet. Dans ce mod√®le, les <b>objets peuvent h√©riter directement d'autres objets</b> gr√¢ce au <b>m√©canisme des prototypes</b>.
            </p>

            <h3> Propri√©t√©s h√©rit√©es </h3>

            <p>
                Chaque objet JavaScript poss√®de <b>un lien interne</b> vers un autre objet, qui est consult√© lorsque la propri√©t√© demand√©e n'est pas trouv√©e sur l'objet lui-m√™me (l'objet <code>prototype</code> de son constructeur). Ce m√©canisme est appel√© <code>[[Prototype]]</code> dans la sp√©cification et la propri√©t√© <code>__proto__</code> (ou <code>Object.getPrototypeOf(obj)</code>) permet d'y acc√©der.
            </p>

            <p>
                Lorsqu'une propri√©t√© n'est pas trouv√©e sur un objet, JavaScript la <b>cherche dans son <code>prototype</code>, puis dans le <code>prototype</code> de ce <code>prototype</code></b>, et ainsi de suite, jusqu'√† la fin de la cha√Æne (<code>null</code>).
                Le premier <code>prototype</code> de la cha√Æne correspond √† la propri√©t√© <code>prototype</code> de la classe de notre objet.
            </p>

            <div id="cells78-1"></div>

            <p>
                Lorsqu'une fonction est utilis√©e avec <code>new</code>, <b>sa propri√©t√© <code>prototype</code> permet de d√©finir le <code>prototype</code> des objets cr√©√©s</b>.
            </p>

            <div id="cells78"></div>

            <p>
                Les propri√©t√©s directement rattach√©es √† un objet sont appel√©es <b>propri√©t√©s propres</b> (<i>own properties</i>). Lorsqu'elles sont d√©finies avec <code>this</code> dans le constructeur, elles ne font pas partie du <code>prototype</code> : elles appartiennent directement √† chaque instance. Le <code>prototype</code>, c'est pour les <b>propri√©t√©s partag√©es</b> (les m√©thodes).
            </p>

            <div id="cells80"></div>

            <h3> M√©thodes h√©rit√©es </h3>

            <p>
                Toute fonction associ√©e √† un objet est √©galement une propri√©t√©. Par cons√©quent, une fonction h√©rit√©e se comportera comme n'importe quelle autre propri√©t√©.
            </p>

            <p>
                Par exemple, le <code>__proto__</code> d'un tableau pointe vers le prototype de l'objet <code>Array</code>. C'est pourquoi, un tableau h√©rite de toutes les propri√©t√©s et m√©thodes de l'objet <code>Array</code> (<code>length</code>, <code>map</code>, etc.).
            </p>

            <p>
                La programmation orient√©e prototype offre, par cons√©quent, la possibilit√© d'ajouter des m√©thodes √† tout moment en dehors de la fonction constructeur. Il est possible par exemple d'ajouter une m√©thode au prototype de l'objet <code>Array</code> (cette pratique, d'ajouter des fonctions aux objets natifs, <b>est cependant d√©conseill√©e</b>).
            </p>

            <div id="cells82"></div>

            <p>
                Voici un exemple complet d'h√©ritage avant la version ES6. Il est possible d'utiliser <b>la fonction <code>call()</code> de l'objet <code>Function</code> pour cha√Æner le constructeur d'un objet</b>.
            </p>

            <div id="cells83"></div>

            <p>
                Voici un exemple complet d'h√©ritage apr√®s la version ES6. Le sucre syntaxique ajout√© lors de la version ES6 exploite <b>le mot-cl√© <code>extends</code></b> pour h√©riter des attributs et des m√©thodes d'une classe.
            </p>

            <div id="cells84"></div>
            
            <div class="nota-bene-box">
                <div class="nota-bene-header">
                    <span class="box-icon">üìù</span>
                    <span class="box-title">√Ä savoir</span>
                </div>
                <div class="box-content">
                    <p> JavaScript ne supporte pas l'h√©ritage multiple. </p>
                </div>
            </div>
            
            <h3> Attributs et m√©thodes statiques </h3>

            <p>
                Le mot-cl√© <code>static</code> permet de d√©finir <b>un attribut ou une m√©thode statique</b> d'une classe. Les attributs ou les m√©thodes statiques ne sont pas disponibles sur les instances d'une classe mais <b>sont appel√©s sur la classe elle-m√™me</b>. Les m√©thodes statiques sont g√©n√©ralement des fonctions utilitaires (qui peuvent permettre de cr√©er ou de cloner des objets par exemple).
            </p>

            <div id="cells85"></div>

            <h3> La copie d'un objet </h3>

            <p>
                Les objets en JavaScript sont mutables : <b>lorsqu'on affecte un objet √† une variable, celle-ci contient une r√©f√©rence vers l'objet</b>, et non une copie de sa valeur.
            </p>

            <div id="cells86"></div>

            <p>
                La m√©thode <code>Object.assign()</code> peut √™tre utilis√©e afin de copier <b>les valeurs de toutes les propri√©t√©s propres d'un objet</b> qui sont √©num√©rables sur un autre objet.
            </p>

            <div id="cells88"></div>

            <div class="nota-bene-box">
                <div class="nota-bene-header">
                    <span class="box-icon">üìù</span>
                    <span class="box-title">√Ä savoir</span>
                </div>
                <div class="box-content">
                    <p>
                        <code>structuredClone()</code> est une m√©thode native moderne de JavaScript qui permet de cloner l'√©tat d'un objet, mais pas son comportement : les m√©thodes et la cha√Æne de prototypes ne sont pas conserv√©es.
                    </p>
                </div>
            </div>

            <div id="cells88_1"></div>

            <h3> Le mot-cl√© <code>this</code> </h3>

            <p>
                <code>this</code> <b>permet √† une fonction d'acc√©der au contexte dans lequel elle est utilis√©e</b>, c'est-√†-dire l'objet ‚Äúcourant‚Äù sur lequel elle agit.
            </p>

            <p>
                √Ä la diff√©rence de la plupart des langages, le mot-cl√© <code>this</code> <b>n'est pas li√© √† un objet en particulier</b>. Sa valeur ne d√©pend pas de l'endroit o√π la fonction a √©t√© d√©clar√©e mais de la <b>fa√ßon dont elle est appel√©e</b>. Cela permet notamment √† une m√©thode d'√™tre r√©utilis√©e par diff√©rents objets.
            </p>

            <div id="cells89"></div>

            Lorsqu'une fonction est appel√©e seule, sans objet devant, <code>this</code> est automatiquement li√© √† l'objet global.

            <div id="cells89_1"></div>

            <div id="cells89_2"></div>

            <div id="cells89_3"></div>

            <div class="nota-bene-box">
                <div class="nota-bene-header">
                    <span class="box-icon">üìù</span>
                    <span class="box-title">√Ä savoir</span>
                </div>
                <div class="box-content">
                    <p>
                        Une <b>fonction classique poss√®de un <code>this</code> dynamique</b>, d√©termin√© au moment de l'appel : lorsqu'elle est invoqu√©e comme m√©thode, <code>this</code> r√©f√©rence l'objet appelant. Ainsi, lorsqu'elle est appel√©e sans objet, <code>this</code> ne r√©f√©rence pas l'objet englobant mais l'objet global <code>window</code> (ou <code>undefined</code> en mode strict).
                    </p>
                </div>
            </div>

            <div id="cells89_4"></div>

            <div class="nota-bene-box">
                <div class="nota-bene-header">
                    <span class="box-icon">üìù</span>
                    <span class="box-title">√Ä savoir</span>
                </div>
                <div class="box-content">
                    <p>
                        Les <b>fonctions fl√©ch√©es</b> se distinguent des fonctions classiques en ce qu'elles <b>ne lient pas leur propre <code>this</code></b>. Elles ne cr√©ent donc pas de nouveau contexte de liaison pour <code>this</code>, mais <b>r√©utilisent la valeur de <code>this</code> du contexte lexical dans lequel elles sont d√©finies</b>. Ainsi, lorsque le mot-cl√© <code>this</code> est utilis√© dans une fonction fl√©ch√©e, le moteur JavaScript le r√©sout en remontant la cha√Æne des port√©es lexicales.
                    </p>
                </div>
            </div>

            <div class="exercise-box">
                <div class="exercise-header">
                    <span class="box-icon">üí°</span>
                    <span class="box-title">Exercice</span>
                </div>
                <div class="box-content">
                    <p> Rendez-vous au lien suivant: <a href="https://github.com/PAJEAN/cours_javascript/tree/master/exemples/bfs"><b>https://github.com/PAJEAN/cours_javascript/tree/master/exemples/bfs</b></a> pour r√©aliser le TP sur le parcours en largeur de graphe. </p>
                </div>
            </div>

            <button class="btn toggle-answer" data-pw="re">
                Afficher la r√©ponse
            </button>
            <div class="hidden">

<textarea class="editor mt" spellcheck="false">
class Graph {
    constructor(matrix) {
        this.matrix = matrix;
    }
    /* Node name from their index */
    _nodeName(index) { return `n${index}`; }
    /* Convert the adjacency matrix to dot language in order to use viz.js */
    _toDotLanguage() {
        let _createId = (num1, num2) => `${num1}${num2}`;

        let graph = [];
        let seen_indexes = {};
        for (let i = 0; i < this.matrix.length; i++) {
            for (let j = 0; j < this.matrix.length; j++) { // this.matrix is a square matrix (same number of rows and columns).
                let id = _createId(i, j);

                if (id in seen_indexes || this.matrix[i][j] == 0) continue;

                let is_dir_both = false;
                if (this.matrix[j][i] == 1) {
                    is_dir_both = true;
                    seen_indexes[_createId(j, i)] = true;
                }
                graph.push(`${this._nodeName(i)} -> ${this._nodeName(j)}${is_dir_both ? ' [dir="both"]': ''}`);
            }
        }
        return `digraph { ${graph.join(' ')} }`;
    }
    /* Compute all distances between all nodes and a given node */
    distance(i_root) {
        let distances = {[this._nodeName(i_root)]: 0};
        let current_distance = 1;
        let queue = [i_root];
        while (queue.length > 0) {
            let current_node_index = queue.shift();
            let current_node = this.matrix[current_node_index];
            for (let j = 0; j < current_node.length; j++) {
                if (this._nodeName(j) in distances || current_node[j] == 0) continue;
                distances[this._nodeName(j)] = current_distance;
                queue.push(j);
            }
            current_distance += 1;
        }
        console.log(distances);
        return distances;
    }
    /* Display graph */
    display() {                    
        let viz = new Viz();
        viz.renderSVGElement(this._toDotLanguage())
        .then(function(element) {
            document.body.appendChild(element);
        })
        .catch(error => {
            // Possibly display the error
            console.error(error);
        });
    }
}

var matrix = [
    [0, 1, 1, 1, 0],
    [0, 0, 1, 0, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 0, 0, 0]
];

let graph = new Graph(matrix);
graph.display();
for (let i = 0; i < this.matrix.length; i++) {
    graph.distance(i);
}
</textarea>

            </div>

        </div>
    </div>


<!--
88888888888                              888          888            
    888                                  888          888            
    888                                  888          888            
    888   .d88b.  88888b.d88b.  88888b.  888  8888b.  888888 .d88b.  
    888  d8P  Y8b 888 "888 "88b 888 "88b 888     "88b 888   d8P  Y8b 
    888  88888888 888  888  888 888  888 888 .d888888 888   88888888 
    888  Y8b.     888  888  888 888 d88P 888 888  888 Y88b. Y8b.     
    888   "Y8888  888  888  888 88888P"  888 "Y888888  "Y888 "Y8888  
                                888                                  
                                888                                  
                                888                                  
-->

    <div id="template-container"></div>


<!--
 .d8888b.                   d8b          888    
d88P  Y88b                  Y8P          888    
Y88b.                                    888    
 "Y888b.    .d8888b 888d888 888 88888b.  888888 
    "Y88b. d88P"    888P"   888 888 "88b 888    
      "888 888      888     888 888  888 888    
Y88b  d88P Y88b.    888     888 888 d88P Y88b.  
 "Y8888P"   "Y8888P 888     888 88888P"   "Y888 
                                888             
                                888             
                                888             
-->

    <script src="../js/main.js"></script>

    <script>
        /* ==== Add cells ==== */
   
addCell('cells74', 'Syntaxe litt√©rale', `
let ma_cle = 'nom_magicien';
let heros = {
    nom: 'Geralt', //Propri√©t√© de l'objet.
    profession: 'Sorceleur', // Propri√©t√© de l'objet.
    10: 'Une partie de Gwent ?', // Propri√©t√© de l'objet.
    'monstres tu√©s': 134, // Propri√©t√© de l'objet.
    direBonjour: function() { // M√©thode de l'objet.
        console.log('Humm !');
    },
    [ma_cle]: 'Yennefer' // Instanciation d'une cl√© 
}
console.log(heros.nom);
console.log(heros[10]);
console.log(heros['monstres tu√©s']);
heros.direBonjour();
console.log(heros[ma_cle]);
console.log(heros.nom_magicien);
`);

addCell('cells75', 'Constructeur <code>Object</code>', `
let heros = new Object(); // On cr√©√© une instance de Object gr√¢ce √† son constructeur.
heros.nom = 'Geralt'; // Propri√©t√©.
heros.direBonjour = function() { // M√©thode de l'objet.
    console.log('Humm !');
};
heros.direBonjour();
`);

addCell('cells76', 'Constructeur personnalis√©', `
function afficher() {
    console.log(this.nom + ' ' + this.age);
}

function Animal(nom, age) { // Constructeur.
    this.nom = nom;
    this.age = age;
    // D√©finition de la m√©thode toString √† partir de la fonction afficher.
    this.toString = afficher;
}

let animal1 = new Animal('Flipper', 8);
let animal2 = new Animal('Beethoven', 4);
console.log(animal1.nom);
console.log(animal2.nom);

// Utilisation de la m√©thode valueOf().
console.log(animal1.valueOf());
`);

addCell('cells77', 'Constructeur personnalis√© (syntaxe alternative)', `
class Animal {
    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
    }

    // D√©finition de la m√©thode toString().
    toString() {
        console.log(this.nom + ' ' + this.age);
    }
}

var animal1 = new Animal('Flipper', 8);
console.log(animal1.nom);
console.log(animal1.valueOf());
`);

addCell('cells78', 'Cha√Æne de prototypage (1/2)', `
function Personne(name) {
  this.name = name;
}

// Chaque fonction a une propri√©t√© "prototype".
console.log(Personne.prototype); // Visualiser avec la console du navigateur.

let p1 = new Personne('Alice');

// L'objet cr√©√© avec new h√©rite de Personne.prototype
console.log(p1.__proto__ === Personne.prototype);
console.log('Prototype de Object: ');
console.log(p1.__proto__.__proto__ === Object.prototype);
console.log('Prototype du prototype de Object: ');
console.log(p1.__proto__.__proto__.__proto__ === null);
`);

addCell('cells78-1', 'Propri√©t√© <code>__proto__</code>', `
const obj = { a: 1 };
console.log(obj.__proto__ === Object.prototype);
`);

addCell('cells80', 'Cha√Æne de prototypage (2/2)', `
let un_objet = function() {
    this.a = 1;
    this.b = 2;
}

un_objet.prototype.b = 3;
un_objet.prototype.c = 4;

let o1 = new un_objet();

// Quelles sont les sorties de ces instructions ?
console.log('o1.a ' + o1.a);
console.log('o1.b ' + o1.b);
/* Je n'ai pas la propri√©t√© "c" dans mes propri√©t√©s propres
Je remonte la cha√Æne de prototypage, est ce que le prototype de mon constructeur (un_objet) a cette propri√©t√© ?
Oui la propri√©t√© est pr√©sente, je l'affiche */
console.log('o1.c ' + o1.c);
// __proto__ est un getter pour acc√©der √† un_objet.prototype.
console.log('o1.__proto__.b ' + o1.__proto__.b);
`);

addCell('cells82', 'Extension du prototype', `
Array.prototype.manger = function() { 
    console.log('Il est beau mon tableau.');
}

var mon_tableau = [1, 2, 3];
mon_tableau.manger();
`);

addCell('cells83', 'H√©ritage', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
}

Animal.prototype.manger = function() { 
    console.log(this.nom + ' est en train de manger.');
}

function Chien(nom, age, race) {
    Animal.call(this, nom, age); // H√©ritage des attributs.
    this.race = race;
}

Chien.prototype = Object.create(Animal.prototype); // H√©ritage des m√©thodes.

var chien1 = new Chien('Snoopy', 10, 'Labrador');
console.log(chien1.nom + ' est un(e) ' + chien1.race);

chien1.manger();

Animal.prototype.getAge = function() {
    return this.nom + ' a ' + this.age + 'ans';
}

console.log(chien1.getAge());
`);

addCell('cells84', 'H√©ritage (syntaxe alternative)', `
class Animal {
    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
    }
    
    manger() {
        console.log(this.nom + ' est en train de manger.');
    }
}

class Chien extends Animal {
    constructor(nom, age, race) {
        super(nom, age);
        this.race = race;
    }
    
    manger() {
        super.manger();
        console.log('Il mange des croquettes.');
    }
    
}

var chien1 = new Chien('Snoopy', 10, 'Labrador');
console.log(chien1.nom);
chien1.manger();
`);

addCell('cells85', 'Attributs et m√©thodes statiques', `
class Animal {
    static count = 0;

    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
        Animal.count++;
    }
    
    manger() {
        console.log(this.nom + ' est en train de manger.');
    }
    
    static Count() {
        return Animal.count;
    }
}

console.log(Animal.count);
var animal1 = new Animal('Flipper', 8);
console.log(Animal.Count());
var animal2 = new Animal('Snoopy', 10);
console.log(Animal.Count());

/* == Cette instruction est-elle viable ? == */

animal2.Count();
`);

addCell('cells86', 'Copie par r√©f√©rence', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
}

var animal1 = new Animal('Flipper', 8);
// Adressage par r√©f√©rence.
var animal2 = animal1;

/* == Quel sera le r√©sultat ? == */

console.log(animal1.nom + ' ' + animal2.nom);

animal2.nom = "Beethoven";

console.log(animal1.nom + ' ' + animal2.nom);
`);

addCell('cells88', 'M√©thode <code>assign()</code>', `
function Animal(nom, age) { // Cr√©ation d'une fonction constructeur.
    this.nom = nom;
    this.age = age;
    this.taille_poids = [120, 50];
}

Animal.prototype.getAge = function() {
    return this.nom + ' a ' + this.age + ' ans';
}

var animal1 = new Animal('Flipper', 8);

// Cr√©ation d'un nouvel objet en utilisant le prototype d'animal1.

var animal2 = Object.assign(Object.create(Animal.prototype), animal1);

animal2.nom = 'Beethoven';
animal2.age = 12;
animal2.taille_poids[0] = 1000;

/* == Quel sera le r√©sultat ? == */

console.log(animal1.getAge());
console.log(animal2.getAge());

/* == Quel sera le r√©sultat ? == */

console.log(animal1.taille_poids, animal2.taille_poids);

var animal3 = Object.assign(Object.create(Animal.prototype), structuredClone(animal1));

animal3.taille_poids[0] = 4;

console.log(animal1.taille_poids, animal3.taille_poids);
`);

addCell('cells88_1', 'Syntaxe alternative', `
class Animal {
    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
        this.taille_poids = [100, 50];
    }
    
    manger() {
        console.log(this.nom + ' est en train de manger.');
    }
}

var animal1 = new Animal('Flipper', 8);
var animal2 = Object.assign(new Animal(), animal1);

animal2.nom = 'Beethoven';
animal2.age = 12;
animal2.taille_poids[0] = 1000;

animal1.manger();
animal2.manger();

console.log(animal1.taille_poids, animal2.taille_poids);

var animal3 = Object.assign(new Animal(), structuredClone(animal1));

animal3.taille_poids[0] = 4;

console.log(animal1.taille_poids, animal3.taille_poids);
`);

addCell('cells89', 'Le mot cl√© <code>this</code>', `
let pierre = { name: 'Pierre' };
let mathilde = {name: 'Mathilde', age: 32 };

function disBonjour(){
  console.log('Bonjour ' + this.name);
}

pierre.bonjour = disBonjour;
mathilde.bonjour = disBonjour;

pierre.bonjour();
mathilde.bonjour();
`);

addCell('cells89_1', 'Appel sans un objet', `
function getThis() {
    console.log(this);
};
getThis();
`);

addCell('cells89_2', 'Appel avec un objet', `
var objet = {
    id: 'Mon objet',
    getContext: function() {
        console.log(this);
    }
}
objet.getContext(); // Fonction appel√©e comme m√©thode via l'objet.
`);

addCell('cells89_3', "Fonction imbriqu√©e au sein d'une m√©thode", `
let objet = {
    id: 'Mon objet',
    getContext: function() {
        let innerFunction = function() {
            console.log(this);
        }
        innerFunction(); // Fonction appel√©e seule.
    }
}
objet.getContext();
`);

addCell('cells89_4', "Fonction fl√©ch√©e", `
let objet = {
    id: 'Mon objet',
    getContext: function() {
        let innerFunction = () => {
            console.log(this);
        }
        innerFunction();
    }
}
objet.getContext();
`);
    
/*        
    addCell('cells00', '', `

    `);
*/

    </script>
</body>
</html>